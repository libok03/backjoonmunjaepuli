#1931

# # 문제
# # 한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 
# 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 
# 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 
# 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 
# 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다.
#  이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.

# # 입력
# # 첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다.
#  둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 
#  이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 
#  시작 시간과 끝나는 시간은 231-1보다 작거나 같은 자연수 또는 0이다.

# # 출력
# # 첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력한다.





# N개 입력 받기
N= int(input())


# N개의 회의들 입력 받기
lst=[]

for i in range(N):
    start, end= map(int,input().split())
    lst.append([start,end])

# 이다음으로 해야하는 일은 입력받은 내용을 토대로 최대 횟수를 출력하는 것이다. 
# 이 내용은 그리디 알고리즘을 이용하여 풀면 풀리는 문제로, 
# 먼저 가장 빨리 시작하는 미팅 시간을 찾고, 그 다음 미팅중 가장 빠르게 시작하는 미팅을 찾으면 되는 문제이다.
# 이러면 해야하는 일은 
# 1. 시작시간이 가장 빠른것을 찾고,
# 2. 위 미팅이 끝나는 시간보다는 이후면서 가장 빠른 미팅시작시간을 찾는다.
# 3. 위를 반복하면서 끝날때까지 몇번 반복해는지 확인한다.
# 가 되는 것이다.

#일단 끝나는 순서대로 start와  end를 정렬해보자

lst.sort(key= lambda k: (k[1],k[0]))


# 다음으로 하나하나 가면서 끝 포인트가 다음 시작 보다 크면 카운트 해주면서 넘어가느 식이다.
endPoint=0
ans=0
for Nstart, Nend in lst:
    if endPoint <= Nstart:
        ans+=1
        endPoint = Nend
print(ans)
